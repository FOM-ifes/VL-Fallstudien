---
title: "Lösungsskizze: Random Forest"
subtitle: "Vorhersage Körperfettanteil"
lang: de
author: "Arbeitsgruppe quantitative Methodenausbildung am ifes"
date: last-modified
format: 
  html:
    toc: true
    number-sections: true
    html-math-method: katex
  pdf:
    toc: true
    number-sections: true
    colorlinks: true 
    papersize: a4
bibliography: rf-references.bib
---

```{r}
#| label: setup
#| include: false

library(mosaic)
library(here)
library(randomForest)
library(ggplot2)
library(caret)
library(tidyverse)
```

## Einleitung


In dieser Fallstudie werden wir den Random Forest Algorithmus nutzen, um den Körperfettanteil vorherzusagen.
Wir verwenden dazu den Body Fat Datensatz, der verschiedene Messungen wie Gewicht, Größe und Umfänge unterschiedlicher Körperregionen enthält.

Die genaue Bestimmung des Körperfettanteils ist sehr aufwendig und teuer und im Alltag nicht zu vollziehen.
Die Bestimmung des Körperfettanteils eines menschlichen Körpers erfolgte in den vorliegenden Daten mittels der Goldstandardmethode der sog.
Unterwasserwägung nach dem archimedischen Prinzip.
Je schwerer jemand unter Wasser ist, desto höher ist die Dichte des Körpers.
Muskeln haben eine höhere Volumendichte als Fettgewebe.
Je höher das Gewicht unter Wasser ist, desto mehr fettfreie Masse hat dieser Körper.

Da eine Unterwasserwägung sehr aufwendig ist und eine große Apparatur benötigt braucht es für den Alltag Parameter, die leicht zu erheben sind.
Mit dieser Fallstudie analysieren wir welche weiteren, einfacheren anthropometrischen Parameter den Körperfettanteil gut vorhersagen.

Der Datensatz wird aufbereitet, um anthropometrische Parameter aus den Daten zu generieren, die derzeit als aussagekräftig diskutiert werden.

## Entscheidungsbäume (CART)


Um zu verstehen, was der Random-Forest Algorithmus ist und was er macht, ist es zunächst nützlich zu wissen, was Entscheidungsbäume sind.

Entscheidungsbäume basieren auf der Idee komplexe Beziehungen, mithilfe von Daten, in einfache "ja/nein"-Fragen aufzubrechen.
Die Struktur eines Entscheidungsbaumes ergibt sich dabei wie folgt:  
an jedem Knotenpunkt (Node), beginnend mit der Wurzel des Baumes (Root Node), splittet der Entscheidungsbaum die Beobachtungen der Zielvariable (abhängige Variable) anhand der Prädiktorvariablen (unabhängige Variablen) in jeweils zwei Submengen.
Dies passiert so lange, bis ein zuvor definiertes Abbruchkriterium erreicht wird.

Es können zwei Arten von Entscheidungsbäumen unterschieden werden, Klassifikations- und Regressionsbäume (Classification- an Regression Trees - CART).  
**Klassifikationsbäume** werden zur Vorhersage einer kategorialen Zielvariablen verwendet, während  
**Regressionsbäume** zur Vorhersage einer metrischen Zielvariablen eingesetzt werden.  

Der CART-Algorithmus ist nur eine von vielen Methoden, um Entscheidungsbäume zu erzeugen, sie ist aber die Grundlage für viele baumbasierte Machine-Learning-Algorithmen wie Random Forest.

![Quelle: eigene Darstellung](img/Beispiel-Klassifikationsbaum.png)

## Random Forest


Random Forest ist ein von @breiman_random_2001 entwickelter Machine-Learning-Algorithmus, der die Ergebnisse vieler verschiedener Entscheidungsbäume kombiniert, um bestmögliche Vorhersagen zu treffen.

Die Entscheidungungbäume werden dazu auf Basis eines Trainingsdatensatzes erstellt.
Wobei die einzelnen Entscheidungsbäume des RF-Algorithmus auf jeweils leicht verschiedenen Subdatensätzen des ursprünglichen Trainigsdatensatzes trainiert werden.
Diese verschiedenen Subdatensätze werden mithilfe von Bagging (Bootstrap Aggregation) erstellt.
Bagging funktioniert indem eine festgelegte Menge von Bootstrap-Stichproben (d.h. Stichproben der gleichen Größe) durch zufälliges Ziehen von Beobachtungen mit Zurücklegen aus dem Trainigsdatensatz generiert werden.
Damit die Entscheidungsbäume noch verschiedener zueinander werden, werden für die einzelnen Splits der Bäume nicht alle Variablen des Subdatensatzes, auf dem sie trainiert werden, genommen, sondern eine zufällige Teilmenge dieser Variablen.  

Zusammengefasst werden die einzelnen Entscheidungsbäume auf zufällig zusammengesetzten Subdatensätzen, die bei jedem Split eine neue, zufällige Zusammensetzung von Variablen besitzen, erstellt.
Die einzelnen Entscheidungsbäume werden am Ende des Algorithmus zusammengefasst und geben ein Modell zurück, mit dem neue Werte vorhergesagt werden können.

![Quelle: eigene Darstellung](img/RF-Algorithmus.png)

## Daten laden

Als Datengrundlage verwenden wir die Body Fat Datentabelle von Kaggle: [Link Body Fat Daten](https://www.kaggle.com/datasets/fedesoriano/body-fat-prediction-dataset)

```{r}
#| label: data

# Datei (inkl. Pfad)
pfad_bodyfat <- here("data", "Bodyfat.csv")

# Daten einlesen
bodyfat <- read.csv(pfad_bodyfat)

# Überblick über die Daten
head(bodyfat)

# Struktur der Daten (bodyfat)
str(bodyfat)

```

------------------------------------------------------------------------

::: {.callout-tip title="Fragen & Aufgabe zum Datensatz"}
1.  Verschaffen Sie sich einen Überblick über die Daten.

2.  Was ist eine Beobachtungseinheit in diesem Datensatz?

    *Antwort: Eine Beobachtungseinheit ist ein Mensch*

3.  Eruieren Sie in welchen Einheiten die Variablen Height, Weight und Abdomen vorliegen.

    *Antwort: Height - inches, Weight - lbs, Abdomen - cm.*
:::

## Berechnung des Körperfettanteils

Der vorliegende Wert des Körperfettanteils im Datensatz wurde aus der ermittelten Dichte mit der Formel nach @siri_gross_1956 berechnet.
Eine Erklärung können Sie bei @rashmi_evaluation_2019 nachlesen.

$$ 
  bodyfat_{Siri}[\%] = \left(\frac{4.95}{density} - 4.500\right) *100
$$

Eine neuere Formel nach @brozek_densitometric_1963 zeigt eine etwas genauere Schätzung des Körperfettanteils (@guerra_accuracy_2010).
Die Formel ist im Folgenden aufgeführt.

$$ 
   bodyfat_{Brožek}[\%] = \left(\frac{4.575}{density} - 4.142\right) *100
$$

Fügen wir die neue Variable mit der Berechnung nach @brozek_densitometric_1963 in die Datentabelle ein:

```{r}
#| label: formula-check

# Existierende BodyFat-Variable umbenennen
bodyfat <- rename(bodyfat, bodyfat_siri = BodyFat)

# Bodyfat nach Brozeck berechnet
bodyfat <- mutate(bodyfat, bodyfat_brozeck = ((4.58/Density)-4.142)*100)
```

Da die Dichtebestimmung sehr aufwendig und teuer ist, werden heute Surrogatparameter zur Bestimmung des Körperfettanteils genutzt, eingie kennen Sie:

-   BMI

-   Waist-to-Hip Ratio (WHR)

-   Waist-to-Height Ratio (wHtR)

-   Oberarmumfang

Erstellen wir aus den vorliegenden Daten einige der genannten Parameter und ändern noch relevante Einheiten.

## Datenmanagement

Die Struktur `str()`der Daten zeigte bereits, dass die Körpergröße in \[inch\] und das Gewicht in Pfund \[lbs\] angegeben ist.
Diese Variablen werden in diesem Kapitel in SI-Einheiten umgerechnet.
Zusätzlich werden die oben genannten Parameter berechnet.

### Einheiten umrechnen

#### Körpergröße in Meter \[m\]

```{r}
#| label: groesse in m

# Größe umrechnen
bodyfat <- mutate(bodyfat, groesse_m = round(Height * 0.0254, 2))

# Überprüfen der Eingabe
head(bodyfat$groesse_m)

# Löschen der alten Variable
bodyfat$Height <- NULL
```

#### Gewicht in Kilogramm \[kg\]

```{r}
#| label: gewicht_kg

# Gewicht umrechnen
bodyfat <- mutate(bodyfat, gewicht_kg = round(Weight*0.453592, 1))

# Überprüfen der Eingabe
head(bodyfat$gewicht_kg, 10)

# Löschen der alten Variable
bodyfat$Weight <- NULL
```

### Surrogatparameter berechnen

#### Waist-to-hip-ratio (whr)

Ein Surrogatparameter ist die Waist-to-Hip Ratio.
Um diesen Parameter zu berechnen, wird die Variable `abdomen` in waist umbenannt und die Variable `waist` durch `hip` geteilt:

```{r}
#| label: rename_whr

# abdomen = taille = waist
# Umbenennen der Variablen
bodyfat <- bodyfat |> rename(waist = Abdomen)

# whr berechnen
bodyfat <- mutate(bodyfat, whr = (waist/Hip))

# Überprüfen der Eingabe
head(bodyfat$whr)
```

#### Waist to height ratio (wHtR)

Ein weiterer Surrogatparameter ist die Waist-to-Height Ratio.

------------------------------------------------------------------------

::: {.callout-tip title="Aufgabe - Variable wHtR erstellen"}
1.  Erstellen Sie eine adäquate Graphik zur Darstellung der Verteilung der Variable Körpergröße.
    Welche Verteilung zeigt sich?
    
    *Antwort: Die Daten zeigen eine Normalverteilung*

2.  Erstellen Sie eine neue Variable mit dem Namen `wHtR` im gleichen Datensatz.


3.  Überprüfen Sie die Eingabe
:::

```{r}
#| label: wHtR-loesung

# 1. Graphik
histogram(~groesse_m, data = bodyfat)
# 2. wHtR berechnen
bodyfat <- mutate(bodyfat, wHtR = (waist/groesse_m))
# 3. überprüfen der Eingabe
head(bodyfat$wHtR)
```

#### BMI

Der BMI ist heute das bekannteste Maß, um Übergewicht und Adipositas und damit einen erhöhten Körperfettanteil zu diagnostizieren, auch wenn dieser Wert Limitationen aufweist und als Parameter diskutiert wird.  
Der BMI wird wie folgt berechnet:

```{r}
#| label: bmi

# BMI berechnen
bodyfat <- mutate(bodyfat, bmi = gewicht_kg/groesse_m^2)

# überprüfen der Eingabe
head(bodyfat$bmi)

```

### Data-Subset generieren

Variablen aus denen das Körperfett berechnet wurde, werden nicht mit in den Analysedatensatz genommen!

```{r}
#| label: remove_density

# Variablen löschen
bodyfat_siri <- bodyfat |> select(c(-Density, -bodyfat_brozeck))
str(bodyfat_siri)
```

## Trainingsdaten erstellen

Die Daten werden zuerst in Trainings- und Testdaten aufgeteilt.
Diese Einteilung der Daten erlaubt es die Leistung des Random-Forest-Algorithmus zu bewerten, indem man dem Algorithmus nach dem Training unbekannte Daten zur Evaluation der Generalisierbarkeit des Modells gibt.
Dafür werden unter Nutzung des `caret`Paketes zufällig 70% der Beobachtungen des Datensatzes in den Trainigsdatensatz gezogen und die restlichen 30% bilden den Testdatensatz.

```{r}
#| label: trainings-test-data

# Datenaufteilung in Trainings- und Testdaten (caretPaket)
set.seed(42)
trainIndex <- createDataPartition(bodyfat$bodyfat_siri, p = 0.7, list = FALSE)
trainData <- bodyfat_siri[trainIndex, ]
testData <- bodyfat_siri[-trainIndex, ]

# Überblick über die aufgeteilten Daten
dim(trainData)
dim(testData)
```

## Trainineren des Modells

Vor dem Trainieren des Models muss man beachten, dass es sog.
Hyperparameter gibt, die beim RF-Algorithmus eingestellt werden können.
Zu diesen Hyperparameter zählen unter anderem:

`ntree:` gibt die Anzahl der Entscheigungsbäume im RF an.
Die Voreinstellung (default) ist 500.

`mtry:` gibt die Anzahl der zufällig ausgewählten Prädiktorvariablen an jedem Split an.

Standardmäßig ist `mtry`bei $\sqrt{p}$ für die Klassifikation und $\frac{p}{3}$ bei der Regression gesetzt - ändert man diese nicht ab, muss `mtry` auch nicht angegeben werden.
($p$ ist die Anzahl der Prädiktorvariablen).

```{r}
#| label: train-the-model

# Training des Random Forest Modells
set.seed(42)
rf_model1 <- randomForest(bodyfat_siri ~ ., data = trainData, ntree = 500, importance = TRUE)

# Überblick über das Modell
rf_model1
```

## Testen des Modells

Im letzten Schritt hatte das Modell die Möglichkeit anhand des Trainingsdatensatzes Muster und Zusammenhänge in den Daten zu lernen.
Wie gut das dem Modell gelungen ist, kann man herausfinden, in dem man das Modell auf unbekannten Daten (Testdaten) Vorhersagen treffen lässt:

```{r}
# Definition der Beobachteten Werte
observed <- testData$bodyfat_siri

# Vorhersage auf den Testdaten
predictions <- predict(rf_model1, testData)
predictions
```

## Modellgüte

Wie gut sind die Vorhersagen des RF-Modells denn jetzt?

Um das herauszufinden, gibt es sogenannte Modellgütekriterien.
Diese Kriterien quantifizieren, wie weit die vorhergesagten Werte von den tatsächlichen Werten entfernt sind.
Beispiele für Modellgütekriterien bei der Klassifikation sind: Accuracy, Precision, Recall, F1-Score, ROC, AUC etc.
Da wir in dieser Fallstudie allerdings eine stetige Zielvariable untersuchen, konzentrieren wir uns auf Modellgütekriterien für die Regression.
Diese sind unteranderem: MSE, RMSE, MAE, $R^2$.

### MSE

Der MSE (Mean Squared Error) ist die mittlere quadratische Abweichung, auch mittlerer quadratischer Fehler genannt, zwischen dem vorhergesagten und dem wahren Wert.
Berechnet wird der MSE indem die Differenz von vorhergesagten und wahren Wert quadriert, aufsummiert und dann durch die Anzahl der vorhergesahten Werte geteilt wird:

$$ 
  MSE = \frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y_i})^2
$$

Je größer das Ergebnis des MSE, desto größer sind die Vorhersagefehler, die vom Madell gemacht wurden.
Dementsprechend gilt, je kleiner das Ergebnis, desto besser das Modell.

### RMSE

Der RMSE (Root Mean Squared Error) ist die Wurzel des MSE.
Der RMSE hat gegenüber dem MSE den Vorteil, dass dieser besser zu interpretieren ist, da durch das Ziehen der Wurzel die Größe der Fehler wieder der Einheit der tatsächlichen Werte entspricht.

$$ 
  RMSE = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y_i})^2} 
$$

Allerdings hat sowohl der MSE als auch der RMSE das Problem, dass durch den quadrierten Therm Ausreißer stark gewichtet werden.

### MAE

Der MAE (Mean Absolute Error) ist definiert als der Duchschnitt der absoluten Differenz zwischen vorhergesagten Wert und tatsächlichem Wert.
Wie beim MSE und RMSE gilt, je niedrieger der Wert des MAE's desto kleiner sind die Fehler und desto besser ist das Modell.

$$ 
  MAE = \frac{1}{n}\sum_{i=1}^{n}|y_i - \hat{y_i}| 
$$

Der MAE ist im Vergleich zum MSE und RMSE robuter gegenüber Ausreißern und hat, ähnlich wie der RMSE, die gleiche Einheit wie die ursprünglichen Werte der Datentabelle wodurch er besser zu interpretieren ist als der MSE.
Allderdings bestraft der MAE große Fehler nicht so stark wie kleine Fehler und ist anders als der MSE und RMSE nicht differenzierbar, was eine Verwendung des MAE's für weitere mathematische Operationen nicht einfach macht.

### $R^2$

Das $R^2$ gibt den Anteil der Varianz in der Zielvariable an, der durch das Modell erklärt wird.
Der Ergebnisraum reicht dabei von 0 bis 1, wobei höhere Werte eine bessere Leistung des Modells wiederspiegeln.

$$ 
  R^2 = 1 - \frac{RSS}{TSS} 
$$

Wobei:

-   RSS (Residual Sum of Squares): $\sum_{i=1}^{n}(y_i - \hat{y_i})^2$

-   TSS (Total Sum of Squares): $\sum_{i=1}^{n}(y_i - \overline{y})^2$

------------------------------------------------------------------------

::: {.callout-tip title="Frage - Modellgüte"}
1.  Berechnen Sie den MSE. Wie ist er sinnvoll zu interpretieren?

```{r}
#MSE 
mse <- mean((predictions - observed)^2) 
mse
```

MSE zeigt den quadrierten Fehler, die Einheit ist ebenfalls quadriert.
Die mittlere quadratische Abweichung zwischen dem vorhergesagten und dem tatsächlichen Körperfettanteil beträgt somit `r round(mse, 2)` $\%^2$.

2.  Das Ziehen der Wurzel ermöglicht eine einfachere Interpretation (RMSE).

```{r}
# RMSE
rmse <- sqrt(mse)
rmse
```

Im Mittel beträgt die Abweichung vom vorhergesagten und dem tatsächlichen Wert des Körperfettanteils `r round(sqrt(mse), 2)` %.

3.  Berechnen Sie den MAE. Ist eine Verwendung des MAE's hier sinnvoll?

```{r}
#MAE 
mae <- mean(abs(predictions - observed))
mae
```

3.  Berechnen Sie nun noch das $R^2$ und interpretieren Sie es.

```{r}
# R2 
rss <- sum((predictions-observed)^2) ## residual sum of squares 
tss <- sum((observed - mean(observed)) ^ 2)  ## total sum of squares 
rsq <- 1 - rss/tss
rsq
```

Es werden `r round(rsq, 2)` % der Varianz der Zielvariable durch das Modell erklärt.
:::

## Modelloptimierung

Dem vorherigen Kapitel können wir entnehmen, wie gut das Model performt bspw.
wieviel der Varianz der Zielvariable erklärt wird.
Allerdings sind das die Ergebnisse eines Modells bei welchem wir einfach die Standardeinstellungen der Hyperparameter übernommen haben.
Es gibt eine Möglichkeit diese Hyperparameter so einzustellen, dass unser Model noch bessere Vorhersagen macht: das Hyperparameter-Tuning.

Für das Tunen der Hyperparameter brauchen wir das `caret`-Paket.

### Grid-Search

Bei der Rastersuche oder Grid Search werden alle möglichen Kombinationen der angegebenen Hyperparameterwerte ausprobiert, um das beste Modell zu finden.
Das beste Modell findet der RF-Algorithmus mit Hilfe der Kreuzvalidierung.

Mit dem Befehlt `method = "cv"` wird eine Kreuzvalidierung zur Optimierung des Modells durchgeführt.

**Vorgehen:**

* der Trainingsdatensatz in $k$ gleichgroße Teilmengen geteilt.  
* es efolgt ein iteratives Training und Testen.  
* in jedem Durchlauf wir ein Testset verwendet und $k-1$ dienen als Trainingsdatensatz.  
* Ablauf wird $k$-fach ($k$-fold) wiederholt, so dass jeder Fold einmal als Testset fungiert.  

Um die Rechenzeit nicht zu groß werden zu lassen, tunen wir nur den mtry-Hyperparameter.
Legen wir los:

```{r}
# Hyperparameter-Tuning mit dem caret Paket
control <- trainControl(method = "cv", number = 5)
tuneGrid <- expand.grid(.mtry = c(2, 4, 6, 8, 10))

# Trainieren des Modells mit Hyperparameter-Tuning
set.seed(42)
rf_tuned <- train(bodyfat_siri ~ ., data = trainData, method = "rf", trControl = control, tuneGrid = tuneGrid)
rf_tuned

# Beste Parameter
best_mtry <- rf_tuned$bestTune$mtry
best_mtry

# Vorhersage auf den Testdaten mit dem getunten Modell
predictions_tuned <- predict(rf_tuned, testData)

# Berechnung der Vorhersagegenauigkeit des getunten Modells
mse_tuned <- mean((predictions_tuned - observed)^2)
rmse_tuned <- sqrt(mse_tuned)
```

Zum Abschluss können die Modellgütemaße des ersten Random Forest und dem getunten Modell verglichen werden:

```{r}

# Ursprungsmodel
mse
rmse <- sqrt(mse)
rmse

#optimiertes Modell
mse_tuned
rmse_tuned

```

------------------------------------------------------------------------

## Variablen identifizieren

Zum Schluss kann man sich noch anschauen, welche Variable bei der Vorhersage besonders relevant war und welche Variablen nicht so relevant gewesen sind.
Dabei bezieht sich die Relevanz einer Variable darauf, wie sehr ein bestimmtes Modell diese Variable „nutzt“, um möglichst genaue Vorhersagen zu treffen.
Je mehr ein Modell diese Variable „nutzt“, um Vorhersagen zu treffen, desto wichtiger ist sie für das Modell.

Lassen Sie uns die wichtigsten Variablen identifizieren, die das erste (nicht getunte) Modell verwendet hat, um die Vorhersagen zu treffen.

```{r}
# Wichtige Variablen
importance <- importance(rf_model1)
importance
```

%IncMSE (Percent Increase in MSE): bezieht sich auf die prozentuale Zunahme des MSE.
Ein hoher %IncMSE deutet auf eine wichtige Variable für die Vorhersagegenauigkeit des Modells hin.
%IncMSE erlaubt eine Erstellung einer Rangordnung der Variablen im RF und der Identifizierung der einflussreichsten Prädiktoren im Modell.

```{r}
# Dataframe varImportance erstellen
varImportance <- data.frame(Variables = row.names(importance), Importance = importance[, 1])

# Importance Graphik
gf_col(Importance ~ reorder(Variables, Importance), data = varImportance, fill = "darkblue") |>
  gf_refine(coord_flip()) |>
  gf_theme(theme_minimal()) |>
  gf_labs(title = "Variable Importance Modell1", 
          x = "Variables", 
          y = "Importance")
```

------------------------------------------------------------------------

::: {.callout-tip title="Your Turn"}
Erstellen Sie ein Random Forest Modell mit der Berechnung nacn Brozek (`body_fat_brozek`)

- Erstellen Sie einen Datensatz mit der Zielvariable `bodyfat_brozeck`:

```{r}

bodyfat_brozeck <- bodyfat |> select(c(-Density, -bodyfat_siri))
str(bodyfat_brozeck)
```

- Erstellen Sie einen Test- und Trainingsdatensatz

```{r}
set.seed(42)
trainIndex <- createDataPartition(bodyfat$bodyfat_brozeck, p = 0.7, list = FALSE)
trainData2 <- bodyfat_brozeck[trainIndex, ]
testData2 <- bodyfat_brozeck[-trainIndex, ]
```

- Erstellen Sie ein RF-Modell mit den Standardeinstellungen für die Hyperparameter

```{r}
# Training des Random Forest Modells
set.seed(42)
rf_model2 <- randomForest(bodyfat_brozeck ~ ., data = trainData2, ntree = 500, importance = TRUE)


# Überblick über das Modell
rf_model2
```

- Eruieren Sie die wichtigsten Variablen

```{r}
# Wichtige Variablen
importance2 <- importance(rf_model2)

varImportance2 <- data.frame(Variables = row.names(importance2), Importance = importance2[, 1])

gf_col(Importance ~ reorder(Variables, Importance), data = varImportance2, fill = "darkgreen") |>
  gf_refine(coord_flip()) |>
  gf_theme(theme_minimal()) |>
  gf_labs(title = "Variable Importance Modell2", 
          x = "Variables", 
          y = "Importance")
```

- Zeigt sich ein Unterschied in den Modellen bei den wichtigen Variablen und der MSE?

```{r}
# Modell 1
mse

#Modell 2 
observed2 <- testData2$bodyfat_brozeck
predictions2 <- predict(rf_model2, testData2)

mse2 <- mean(abs(predictions2 - observed2)^2)   
mse2
```
:::

------------------------------------------------------------------------
